# File Content Filter (SHIFT Java test task)

Утилита командной строки для фильтрации содержимого входных файлов по типам данных: целые числа, вещественные числа, строки – с записью каждого типа в отдельный выходной файл и (опционально) выводом статистики

> Входные данные могут быть перемешаны. Разделитель записей – перевод строки: одна входная строка = одно значение

---

## Возможности

- Построчная (потоковая) обработка входных файлов – подходит для очень больших файлов (десятки ГБ)
- Чтение входных файлов строго по порядку, в котором они указаны в командной строке (файл 1 целиком, затем файл 2 и т.д.)
- Запись результатов в:
  - `integers.txt` – целые
  - `floats.txt` – вещественные
  - `strings.txt` – строки
- Опции:
  - `-o` – директория результата
  - `-p` – префикс выходных файлов
  - `-a` – режим добавления (append), по умолчанию перезапись
  - `-s` – краткая статистика
  - `-f` – полная статистика
- Ленивая генерация: выходной файл создаётся только если реально встретились данные этого типа
- Обработка ошибок: утилита не “падает”, при возможности продолжая работу (частичная обработка)

---

## Требования

- Зависимости: `picocli` (для CLI) – версия указана в build-файлах проекта
- Java: 14+

> Минимальная версия для текущего кода – Java 14 (из-за `switch` со стрелками `case X ->`, но при желании можно откатить утилиту до более старых версий).
> - Java 11: заменить `case X ->` на обычный `switch` (`case X:` + `break`).
> - Java 8: дополнительно заменить `Path.of` на `Paths.get`, `strip()` на `trim()` или аналог, `var` на явные типы, `Map.of` на обычная инициализацию


---

## Использование

### Справка

```bash
java -jar <app>.jar --help
java -jar <app>.jar -V
```

### Синтаксис

```bash
java -jar <app>.jar [OPTIONS] <filepath>...
```

- Нужно указать минимум один входной файл
- `-s` и `-f` взаимоисключающие (если указать оба – будет ошибка парсинга)

---

## Опции CLI

| Опция |  Параметр  | По умолчанию | Описание |
|------:|:----------:|:------------:|----------|
| `-o` |  `<path>`  | `.` | Директория для результатов |
| `-p` | `<prefix>` | пусто | Префикс имён выходных файлов |
| `-a` |     -      | выключено | Append-режим. Если не задано – перезапись |
| `-s` |     -      | выключено | Краткая статистика (только количество) |
| `-f` |     -      | выключено | Полная статистика |

> Если не указан ни `-s`, ни `-f`, статистика не выводится (режим `NoStats`)

---

## Примеры

### 1) Краткая статистика, append, префикс

```bash
java -jar <app>.jar -s -a -p sample- in1.txt in2.txt
```

Результаты (пример):
- `sample-integers.txt` – все целые
- `sample-floats.txt` – все вещественные
- `sample-strings.txt` – все строки
- В консоли – количества записанных элементов по каждому типу.

### 2) Вывод в отдельную папку

```bash
java -jar <app>.jar -o /some/path -p result_ -f in1.txt in2.txt
```

Файлы:
- `/some/path/result_integers.txt`
- `/some/path/result_floats.txt`
- `/some/path/result_strings.txt`

---

## Формат входных данных

- Каждый входной файл – текстовый.
- Разделитель значений: перенос строки (`\n`)
- Значения любых типов могут встречаться вперемешку

---

## Формат выходных данных

- Файлы результатов:
  - `integers.txt`, `floats.txt`, `strings.txt` (или с префиксом `-p`)
- Разделитель – перенос строки.
- Кодировка ввода/вывода: UTF‑8.
- Ленивая генерация файлов: если данные определённого типа не встречались – соответствующий файл не создаётся

---

## Определение типа значения

Классификация выполняется по `line.strip()` (пробелы по краям игнорируются при определении типа)

Порядок определения:

1. **_INTEGER_** – регулярное выражение  
   `^[+-]?\d+$`
2. **_FLOAT_**  регулярное выражение (включая scientific notation)  
   `^[+-]?(?:\d+\.?\d*|\.\d+)(?:[eE][+-]?\d+)?$`
3. Иначе – **_STRING_**

Особенности:
- Пустая строка после `strip()` = **_STRING_**
- `1e-3`, `1.528535047E-25` = **_FLOAT_**
- `NaN`, `Infinity`, необычные форматы = **_STRING_**
- Десятичный разделитель для _**FLOAT**_ – точка

---

## Нормализация при записи

- Для _**INTEGER**_ и _**FLOAT**_ перед записью применяется `strip()`:
  - вход: `"   123   "` → в `integers.txt` попадёт `"123"`
- Для _**STRING**_ строка записывается как есть:
  - пробелы по краям сохраняются
  - строка, состоящая только из пробелов, остаётся строкой и так же является валидным результатом

---

## Статистика

Статистика собирается по каждому типу отфильтрованных данных и выводится в консоль

### `-s` – краткая (`ShortStats`)
- Только количество записанных значений:
  - `Integers written: N`
  - `Floats written:   N`
  - `Strings written:  N`

### `-f` – полная (`FullStats`)

Для **_INTEGER_**
- `min`, `max`, `sum` (тип: `BigInteger`)
- `avg` вычисляется как `BigDecimal(sum) / count` с `MathContext.DECIMAL128`

Для **_FLOAT_**
- `min`, `max`, `sum`, `avg` (тип: `BigDecimal`, `MathContext.DECIMAL128`)

Для **_STRING_**
- `count`
- `minLength`, `maxLength` (по длине строки, не лексикографически)

### Важная деталь про “битые” числа
Если строка классифицирована как число, но не парсится в `BigInteger/BigDecimal`:
- значение всё равно записывается в соответствующий выходной файл, но не учитывается в числовой статистике
- в `stderr` печатается предупреждение

---

## Обработка ошибок и частичная обработка

Цель: **не падать** и по возможности продолжать выполнение

### Ошибки входных файлов
- `No such file` / `Access denied` / `IOException` при чтении:
  - сообщение печатается в `stderr`
  - обработка продолжается со следующими входными файлами

### Ошибки записи результатов
Реализованы два уровня:

1) Фатальные ошибки (продолжать невозможно)
- Например, невозможно создать/использовать директорию `-o` (нет прав, путь не директория и т.п.)
- Утилита сообщает причину и завершает работу с кодом ошибки

2) Нефатальные ошибки (частичная обработка)
- Если запись конкретного выходного файла/типа становится невозможной (например, проблема с `floats.txt`),
  утилита:
  - сообщает об ошибке
  - пропускает дальнейшие значения этого типа
  - продолжает обработку остальных типов и входных файлов

### Код возврата
- `0` – ошибок не было
- `1` – были ошибки чтения и/или записи (включая частично обработанные случаи)

> Даже при ошибках статистика (если включена) выводится по тем данным, которые удалось обработать

---

## Производительность и память

- Чтение: `BufferedReader.readLine()` – потоково
- Запись: `BufferedWriter` – потоково, writers открываются по требованию
- Выходные потоки закрываются корректно (try-with-resources / AutoCloseable)

---

## Структура проекта (ключевые классы)

- `Main` – точка входа, запуск `picocli`
- `FilterApp` – CLI-команда: чтение входных файлов, классификация, запись, статистика
- `OutputManager` – управление выходными файлами (ленивое создание, append/overwrite, закрытие ресурсов)
- `ValueType` – enum типов (`INTEGER`, `FLOAT`, `STRING`)
- `statsModes/*`:
  - `StatsModeStrategy` – интерфейс стратегии статистики
  - `NoStats`, `ShortStats`, `FullStats` – реализации
- `ExceptionHandler` – кастомные сообщения об ошибках парсинга аргументов

---

## Используемые библиотеки

- `picocli` – CLI-парсинг (опции `--help`, `--version`, валидация взаимоисключающих аргументов)  
  Версия: см. `pom.xml`
